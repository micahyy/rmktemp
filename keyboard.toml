// main.rs
#![no_std]
#![no_main]

use defmt::*;
use embassy_executor::Spawner;
use embassy_nrf::peripherals;
use rmk::keyboard::{Keyboard, KeyboardConfig};
use rmk::keyboard_matrix::KeyboardMatrix;
use rmk::storage::Storage;

// 定义你的键盘矩阵大小
const ROWS: usize = 4;
const COLS: usize = 12;

#[embassy_executor::main]
async fn main(_spawner: Spawner) {
    // 初始化硬件
    let p = embassy_nrf::init(Default::default());
    
    // ==================== 关键部分开始 ====================
    // 强制清除 EEPROM - 每次启动都执行
    info!("正在清除 EEPROM...");
    force_clear_eeprom();
    info!("EEPROM 清除完成");
    // ==================== 关键部分结束 ====================
    
    // 创建键盘矩阵
    let matrix = KeyboardMatrix::new(/* 你的矩阵配置 */);
    
    // 创建键盘配置
    let config = KeyboardConfig::default();
    
    // 创建键盘实例
    let keyboard = Keyboard::new(matrix, config);
    
    // 启动键盘
    keyboard.run().await;
}

/// 强制清除 EEPROM
fn force_clear_eeprom() {
    use core::ptr;
    
    // nRF52840 的 Flash 地址范围
    // RMK 通常将 EEPROM 数据放在这里
    const FLASH_START: u32 = 0x000F_0000;
    const FLASH_SIZE: u32 = 0x0000_4000;  // 16KB
    
    info!("擦除 Flash 区域: 0x{:08X} - 0x{:08X}", 
          FLASH_START, FLASH_START + FLASH_SIZE);
    
    // 注意：在实际 Flash 上不能这样直接写
    // 这里只是示意，实际需要调用 Flash 驱动
    unsafe {
        // 获取 Flash 外设
        let flash = peripherals::FLASH0::steal();
        
        // 使能 Flash 写入
        flash.config.write(|w| w.wen().enabled());
        
        // 擦除 Flash 扇区（每个扇区 4KB）
        for sector in 0..(FLASH_SIZE / 4096) {
            let addr = FLASH_START + sector * 4096;
            flash.erasepage.write(|w| unsafe { w.bits(addr) });
            flash.tasks_erase_start.write(|w| w.tasks_erase_start().trigger());
            
            // 等待擦除完成
            while flash.events_ready.read().bits() == 0 {}
            flash.events_ready.write(|w| w);
        }
        
        // 禁用 Flash 写入
        flash.config.write(|w| w.wen().disabled());
    }
    
    // 或者使用 RMK 的存储接口（如果可用）
    clear_rmk_storage();
}

/// 使用 RMK 存储接口清除
fn clear_rmk_storage() {
    // 尝试初始化并清除存储
    if let Ok(mut storage) = Storage::new() {
        match storage.clear() {
            Ok(_) => info!("RMK 存储清除成功"),
            Err(e) => error!("RMK 存储清除失败: {:?}", e),
        }
    } else {
        info!("无法初始化 RMK 存储，使用直接 Flash 操作");
    }
}

[keyboard]
name = "CZMAOWL17"
product_name = "Wireless17"
vendor_id = 0x4c4b
product_id = 0x4643
manufacturer = "CaiZiMao"
chip = "nrf52840"

[features]
vial = { enabled = true }

[matrix]
# Row and col pins are mandatory
row_pins = ["P0_10", "P0_30", "P0_31", "P0_29", "P0_02"]
col_pins = ["P0_05", "P0_13", "P0_24", "P0_09"]
# RMK uses col2row as the default matrix diode direction, if you want to use a row2col matrix, add `row2col = true`
# row2col = true

[layout]
rows = 5
cols = 4
layers = 2
matrix_map = """
(0,0) (0,1) (0,2) (0,3)
(1,0) (1,1) (1,2) (1,3)
(2,0) (2,1) (2,2)
(3,0) (3,1) (3,2) (3,3)
    (4,0)    (4,2)
"""

[[layer]]
name = "base_layer"
keys = """
NumLock    KpSlash    KpAsterisk    KpMinus
Kp7        Kp8        Kp9           KpPlus
Kp4        Kp5        Kp6
Kp1        Kp2        Kp3           KPENTER
    Kp0         KpDot
"""
# Encoder 0 - CW: AudioVolUp, CCW: AudioVolDown
encoders = [["AudioVolUp", "AudioVolDown"]]

[[layer]]
name = "second_layer"
keys = """
TD(1)  TO(0)        WM(W,LShift)         No
DF(0)  LT(1, Space) LM(0, LShift | RGui) 
OSL(0) OSM(LAlt)    TH(Kp1, Kp2)        SHIFTED(Kp2)
    @my_copy        @my_paste
"""
# Encoder 0 - CW: BrightnessUp, CCW: BrightnessDown
encoders = [["BrightnessUp", "BrightnessDown"]]

[aliases]
my_copy = "WM(C, LCtrl)"
my_paste = "WM(V, LCtrl)"

[light]
# All light pins are high-active by default, uncomment if you want it to be low-active
capslock.pin = "P1_13"
capslock.low_active = false
scrolllock.pin = "P0_28"
scrolllock.low_active = false
# Just ignore if no light pin is used for it
numslock.pin = "P1_11"
numslock.low_active = false 

# 蓝牙连接状态指示灯
# ble_led.pin = "P1_11"      # 请替换为你实际想用的、空闲的GPIO引脚，例如 P1_11
# ble.low_active = false # 默认高电平点亮，如果LED是低电平有效则设为 true

[storage]
# Storage feature is enabled by default
# enabled = false
# clear_storage = true

[ble]
enabled = true
# vddh has an internal voltage divider
battery_adc_pin = "P0_04"
adc_divider_measured = 250
adc_divider_total = 500

[behavior.combo]
timeout = "150ms"
combos = [
  # Press J and K keys simultaneously to output "L"
  { actions = [
    "J",
    "K",
  ], output = "L" },
  # Press F and D keys simultaneously to switch to layer 2, but only valid on layer 0
  { actions = [
    "F",
    "D",
  ], output = "TO(1)", layer = 0 },
  # Three-key combo, press A, S, and D keys to output "X"
  { actions = [
    "A",
    "S",
    "D",
  ], output = "X" },
]

[behavior.fork]
forks = [
  # Shift + '.' output ':' key
  { trigger = "Dot", negative_output = "Dot", positive_output = "WM(Semicolon, LShift)", match_any = "LShift|RShift" },

  # Shift + ',' output ';' key but only if no Alt is pressed
  { trigger = "Comma", negative_output = "Comma", positive_output = "Semicolon", match_any = "LShift|RShift", match_none = "LAlt|RAlt" },

  # left bracket outputs by default '{', with shifts pressed outputs '['  
  { trigger = "LeftBracket", negative_output = "WM(LeftBracket, LShift)", positive_output = "LeftBracket", match_any = "LShift|RShift" },

  # Flip the effect of shift on 'x'/'X'
  { trigger = "X", negative_output = "WM(X, LShift)", positive_output = "X", match_any = "LShift|RShift" },

  # F24 usually outputs 'a', except when Left Shift or Ctrl pressed, in that case triggers a macro 
  { trigger = "F24", negative_output = "A", positive_output = "Macro1", match_any = "LShift|LCtrl" },

  # Swap Z and Y keys if MouseBtn1 is pressed (on the keyboard) (Note that these must not be bindable to avoid infinite fork loops!) 
  { trigger = "Y", negative_output = "Y", positive_output = "Z", match_any = "MouseBtn1", bindable = false },
  { trigger = "Z", negative_output = "Z", positive_output = "Y", match_any = "MouseBtn1", bindable = false },

  # Shift + Backspace output Delete key (inside a layer tap/hold)
  { trigger = "LT(2,Backspace)", negative_output = "LT(2,Backspace)", positive_output = "LT(2,Delete)", match_any = "LShift|RShift" },

  # Ctrl + play/pause will send next track. MediaPlayPause -> MediaNextTrack
  # Ctrl + Shift + play/pause will send previous track. MediaPlayPause -> MediaPrevTrack
  # Alt + play/pause will send volume up. MediaPlayPause -> AudioVolUp
  # Alt + Shift + play/pause will send volume down. MediaPlayPause -> AudioVolDown
  # Ctrl + Alt + play/pause will send brightness up. MediaPlayPause -> BrightnessUp
  # Ctrl + Alt + Shift + play/pause will send brightness down. MediaPlayPause -> BrightnessDown
  # ( Note that the trigger and immediate trigger keys of the fork chain could be 'virtual keys', 
  #   which will never output, like F23, but here multiple overrides demonstrated.)
  { trigger = "MediaPlayPause", negative_output = "MediaPlayPause", positive_output = "MediaNextTrack", match_any = "LCtrl|RCtrl", bindable = true },
  { trigger = "MediaNextTrack", negative_output = "MediaNextTrack", positive_output = "BrightnessUp", match_any = "LAlt|RAlt", bindable = true },
  { trigger = "BrightnessUp", negative_output = "BrightnessUp", positive_output = "BrightnessDown", match_any = "LShift|RShift", bindable = false },
  { trigger = "MediaNextTrack", negative_output = "MediaNextTrack", positive_output = "MediaPrevTrack", match_any = "LShift|RShift", match_none = "LAlt|RAlt", bindable = false },
  { trigger = "MediaPlayPause", negative_output = "MediaPlayPause", positive_output = "AudioVolUp", match_any = "LAlt|RAlt", match_none = "LCtrl|RCtrl", bindable = true },
  { trigger = "AudioVolUp", negative_output = "AudioVolUp", positive_output = "AudioVolDown", match_any = "LShift|RShift", match_none = "LCtrl|RCtrl", bindable = false },
]

[rmk]
combo_max_num = 128
fork_max_num = 16

# IGNORE/DONT-INCLUDE THIS SECTION Unless you're using custom nRF52840 based board (Eg not a nice!nano)
[chip.nrf52840]
# DCDC regulator 0 enabled (default: true)
dcdc_reg0 = true
# DCDC regulator 1 enabled (default: true)
dcdc_reg1 = true
# DCDC regulator 0 voltage: "3V3" or "1V8" (default: "3V3")
dcdc_reg0_voltage = "3V3"
